package brown.bag.experiment.types

import brown.bag.experiment.types.model.companyNumber.CompanyNumber
import brown.bag.experiment.types.utils.ConstraintUtil.ConstraintUtil
import brown.bag.experiment.types.utils.ValidationHelper
import brown.bag.experiment.types.utils.ValidationHelper.{validate, validateNot}
import eu.timepit.refined.api.{Refined, RefinedTypeOps, Validate}
import io.estatico.newtype.macros.newtype
import play.api.data.validation.Constraint

object model {

  object companyNumber {

    //type CompanyNumber = Refined[String, CompanyNumberPredicate] // and  using the infix notation will be
    type CompanyNumber = String Refined CompanyNumberPredicate

    final case class CompanyNumberPredicate()

    implicit val companyNumberValidate: Validate.Plain[String, CompanyNumberPredicate] =
      Validate.fromPredicate(
        f = ValidationHelper.validOrNot(_, playConstraints.constraint),
        showExpr = ValidationHelper.toError(_, playConstraints.constraint),
        p = CompanyNumberPredicate()
      )

    object CompanyNumber extends RefinedTypeOps[CompanyNumber, String] {

      def withLastNumberPlus1(aCompanyNumber: CompanyNumber): CompanyNumber = {
        val theRawCompanyNumber = aCompanyNumber.value
        val theNewPrefix: String = theRawCompanyNumber.dropRight(1)
        val lastDigitPlusOne = lastDigitOf(theRawCompanyNumber) + 1
        val theNewDigit: Int = if (lastDigitPlusOne == 10) 0 else lastDigitPlusOne
        CompanyNumber.unsafeFrom(theNewPrefix + theNewDigit.toString)
      }

      private def lastDigitOf(theRawCompanyNumber: String): Int = theRawCompanyNumber.last.asDigit
    }

    object CompanyNumberSyntax {
      implicit class CompanyNumberOps(aCompanyNumber: CompanyNumber) {
        def withLastNumberPlus1(): CompanyNumber =
          CompanyNumber.withLastNumberPlus1(aCompanyNumber)
      }
    }

    object playConstraints {

      private val alphanumericRegex = "^[A-Z0-9]*$"

      private val companyNumberEmpty: Constraint[String] = Constraint("company_number.not_entered")(companyNumber =>
        validate(
          constraint = companyNumber.isEmpty,
          errMsg = "capture-company-number-empty.error"
        )
      )
      private val companyNumberLength: Constraint[String] = Constraint("company_number.min_max_length")(companyNumber =>
        validateNot(
          constraint = companyNumber.length == 8,
          errMsg = "capture-company-number-length.error"
        )
      )
      private val companyNumberFormat: Constraint[String] = Constraint("company_number.wrong_format")(companyNumber =>
        validateNot(
          constraint = companyNumber.toUpperCase matches alphanumericRegex,
          errMsg = "capture-company-number-format.error"
        )
      )
      val constraint: Constraint[String] = companyNumberEmpty andThen
        companyNumberLength andThen
        companyNumberFormat

    }

  }

  object withNewType {

    // Please have a look to https://github.com/estatico/scala-newtype to see what the @newtype macro does
    // behind the scene, what code is generated by the macro:
    // it creates a new type that allow to tag the base type, in this case CompanyNumber.
    // (with no runtime overhead ... as we would have in case of a normal case class)
    // the case class definition here it is a way to define a custom type... not a real case class.
    @newtype case class AnOpeningCompanyNumber(companyNumber: CompanyNumber)

    @newtype case class AClosingCompanyNumber(companyNumber: CompanyNumber)

  }
}
